<!DOCTYPE html>

<html lang="ko">

<script>
  const isLocal = location.hostname === "localhost" || location.protocol === "file:";
  const base = document.createElement("base");
  base.href = isLocal ? "./" : "https://mgpixelart.github.io/avatar-customize-v1/";
  document.head.prepend(base);
</script>

<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Avatar Customizer — FIX10 (BG bottom-left)</title>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js">
let suppressNextClick=false;
</script>
<style>
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,Apple SD Gothic Neo,sans-serif;color:#e8ecf1;background:#0b0d12}
    #app{height:100%;display:grid;grid-template-rows:42px 1fr 30px}
    :root{--rightW: 440px; --leftW:230px; --leftWCollapsed: 48px}

    .topbar{display:flex;align-items:center;justify-content:space-between;height:42px;padding:0 10px;background:#0d1220;border-bottom:1px solid #1d2538}
    .title{display:flex;gap:10px;align-items:center}
    .title h1{margin:0;font-size:1rem;line-height:1}
    .title .meta{font-size:.8rem;color:#95a0b3}
    .actions{display:flex;gap:6px;align-items:center;flex-wrap:wrap}
    .btn{background:#18223a;border:1px solid #243152;color:#e8ecf1;border-radius:8px;padding:4px 8px;font-size:.85rem;cursor:pointer}
    .btn:disabled{opacity:.5;cursor:default}
    .pill{font-size:.78rem;color:#9ac3ff}
    input[type="file"]{display:none}

    .body{height:100%;display:grid;grid-template-columns:var(--leftW) 1fr 6px var(--rightW);gap:8px;padding:8px;min-height:0}
    .body.collapsed{grid-template-columns:var(--leftWCollapsed) 1fr 6px var(--rightW)}

    /* LEFT */
    .left{background:#121621;border:1px solid #1d2538;border-radius:12px;display:flex;flex-direction:column;overflow:hidden;min-height:0}
    .leftHead{display:flex;align-items:center;justify-content:flex-end;padding:8px;border-bottom:1px solid #1d2538}
    .left h2{margin:0;font-size:.9rem;color:#cbd4e6}
    .tablist{list-style:none;margin:0;padding:6px;display:flex;flex-direction:column;gap:6px}
    .tab{display:grid;grid-template-columns:1fr auto;align-items:center;gap:6px;padding:8px;border:1px solid #243152;border-radius:10px;background:#0f1424;cursor:pointer}
    .tab .name{font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .tab .iconPart{display:none}
    .rowbtns{display:flex;gap:6px}
    .icon{width:28px;height:28px;border-radius:8px;display:grid;place-items:center;background:#18223a;border:1px solid #243152;cursor:pointer}
    .icon:hover{outline:2px solid #394b79}
    .collapsed .rowbtns{display:none}
    .collapsed .tab{grid-template-columns:1fr}
    .collapsed .name{display:none}
    .collapsed .tab .iconPart{display:block; text-align:center; font-size:14px}
    .collapsed .leftHead{justify-content:center}
    .collapsed #toggleLeft{font-size:12px; padding:2px 4px}
    #toggleLeft{font-size:10px; padding:2px 4px}

    /* MIDDLE */
    .mid{background:#121621;border:1px solid #1d2538;border-radius:12px;display:grid;grid-template-rows:auto 1fr;min-height:0}
    .colors{display:flex;gap:8px;align-items:center;flex-wrap:wrap;padding:10px;border-bottom:1px solid #1d2538}
    .swatch{width:20px;height:20px;border-radius:999px;border:2px solid #0b0d12;cursor:pointer;outline:1px solid #2a3558}
    .swatch.active{outline:2px solid #6ee7ff}
    .grid {  padding:10px;overflow:auto;display:grid;grid-template-columns:repeat(auto-fill, minmax(90px,1fr));gap:10px;min-height:0;

  /* 추가 부분 */
  place-content:start;
  grid-auto-rows:106px; /* 셀 높이에 맞게 조정 */
}

    .cell{height:106px;background:#0e1426;border:1px solid #2a385e;border-radius:10px;display:grid;grid-template-rows:1fr auto;cursor:pointer;position:relative}
    .cell .thumb{display:grid;place-items:center}
    .cell .thumb img{width:84px;height:84px;image-rendering:pixelated}
    .cell .label{font-size:.8rem;color:#cbd4e6;text-align:center;padding:4px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .cell.active{box-shadow:0 0 0 2px #6ee7ff inset}
    .cell.selected{outline:2px solid #6ee7ff}
    .badge{position:absolute;top:6px;left:6px;font-size:.7rem;background:#2d3748;color:#e2e8f0;border:1px solid #4a5568;padding:1px 6px;border-radius:999px}

    /* SPLITTER */
    .split{background:#1d2538;border-radius:6px;cursor:col-resize}
    .split:hover{background:#2a3656}

    /* RIGHT */
    .right{background:#121621;border:1px solid #1d2538;border-radius:12px;display:grid;grid-template-rows:1fr;min-width:320px;min-height:0}
    .stage{display:grid;grid-template-rows:auto 1fr;min-height:0}
    .framebar{display:flex;flex-direction:column;gap:4px;padding:8px;border-bottom:1px solid #1d2538;background:#10182a}
    .framebar-top{display:flex;gap:6px;align-items:center;justify-content:space-between}
    .framebar-bottom{display:flex;gap:4px;align-items:center;justify-content:flex-start}
    .framebar input[type="number"]{width:72px;background:#0f1424;border:1px solid #243152;color:#e8ecf1;border-radius:8px;padding:4px 6px}
    .zoom-controls{display:flex;gap:4px;align-items:center}
    .zoom-controls .btn{padding:2px 6px;font-size:12px}
    .export-controls{display:flex;gap:4px;align-items:center}
    .export-controls .btn{padding:2px 6px;font-size:12px}
    .tools{display:flex;gap:4px;align-items:center}
    .tools .btn{padding:2px 6px;font-size:12px}
    .view{display:grid;place-items:center;padding:8px;min-height:0}
    .canvasWrap{display:block;overflow:auto;border-radius:12px;border:1px solid #203055;max-width:100%;max-height:100%;width:100%;height:100%;background:#0b0d12;cursor:default;position:relative}
    #sheet{image-rendering:pixelated;display:block}
    #selText{margin-left:auto;text-align:right}
    .zoom-controls-overlay{position:absolute;bottom:8px;right:8px;display:flex;gap:2px;background:rgba(16,24,42,0.9);border-radius:6px;padding:4px;border:1px solid #243152}
    .zoom-controls-overlay .btn{padding:2px 6px;font-size:11px;min-width:24px;height:24px}

    /* FOOTER */
    .status{display:flex;gap:8px;align-items:center;background:#0d1220;border-top:1px solid #1d2538;padding:4px 8px}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;font-size:.82rem;color:#bcd0ff;background:#0f1424;border:1px solid #243152;border-radius:8px;padding:3px 8px;flex:1;overflow:auto;white-space:nowrap}
    .left-group{display:flex;gap:6px;align-items:center}
    .left-group .btn{padding:2px 6px;font-size:12px}
    .left-group .btn#clearSelected{min-width:40px;text-align:center}
  </style>
<style>
/* Hide legacy frame controls */
#framePrev, #frameNext, #frameRange, #frameInput, .frame-range, .frame-select { display:none !important; }
/* Display-only frame label */
#frameLabel { margin-left: 8px; padding: 2px 8px; border-radius: 12px; background: #223; color:#cfe; font-size:12px; }

/* NEW: BG color overlay pinned to bottom-left of preview */
.bg-color-overlay {
  position: absolute;
  bottom: 8px;
  left: 8px;
  background: rgba(16, 24, 42, 0.9);
  padding: 4px 6px;
  border-radius: 6px;
  border: 1px solid #243152;
  display: flex;
  gap: 6px;
  align-items: center;
}
.bg-color-overlay label {
  font-size: 12px;
  color: #e8ecf1;
  cursor: pointer;
}
.bg-color-overlay input[type="color"] {
  width: 24px;
  height: 24px;
  padding: 0;
  border: none;
  cursor: pointer;
  background: none;
}

/* '+' add cell */
.cell.add{border:1px dashed #2a385e;background:#0b0f1f;place-items:center}
.cell.add .plus{font-size:28px;line-height:1;color:#9ab3ff}
.cell.add .label{color:#9ab3ff}



/* 스크롤바 스타일 - 좌우/아래 동일 적용 */
::-webkit-scrollbar {
  width: 10px;  /* 세로 스크롤바 너비 */
  height: 10px; /* 가로 스크롤바 높이 */
}
::-webkit-scrollbar-track {
  background: #0e1426; /* 트랙 배경 */
  border-radius: 8px;
}
::-webkit-scrollbar-thumb {
  background: #394b79; /* 손잡이 색 */
  border-radius: 8px;
  border: 2px solid #0e1426; /* 손잡이 주위 여백 */
}
::-webkit-scrollbar-thumb:hover {
  background: #4ea1ff; /* 호버 시 색상 */
}

</style>
</head>
<body>
<div id="app">
<div class="topbar">
<div class="title">
<h1>Avatar Customizer</h1>
<div class="meta">Sheet 432×256 · Face/Skin/Hair/Outfit</div>
</div>
<div class="actions">
<span class="pill" id="perf">Idle</span>
<!-- BG picker removed from topbar -->
<label class="btn" for="inZip">Open ZIP</label><input accept="application/zip" id="inZip" type="file"/> <label class="btn" for="inDir">Open Folder</label><input accept="image/*" directory="" id="inDir" multiple="" type="file" webkitdirectory=""/><input accept="image/*" id="inFiles" multiple="" style="display:none" type="file"/>
<button class="btn" disabled="" id="allRand" type="button">전체 랜덤</button>
</div>
</div>
<div class="body" id="bodyGrid">
<aside class="left" id="leftPanel">
<div class="leftHead">
<button class="btn" id="toggleLeft" title="접기/펼치기" type="button">◀</button>
</div>
<div class="tablist" id="tablist"></div>
</aside>
<section class="mid">
<div class="colors" id="colorBar"></div>
<div class="grid" id="grid"></div>
</section>
<div class="split" id="split"></div>
<aside class="right">
<div class="stage">
<div class="framebar">
<div class="framebar-top">
<div class="left-group">
<span class="pill">프레임 <span id="frameLabel">-</span></span>
</div>
</div>
<div class="framebar-bottom">
<div class="export-controls">
<select id="exportScale" style="margin-right:6px;" title="저장 배율">
<option selected="" value="1">1x</option>
<option value="2">2x</option>
<option value="3">3x</option>
<option value="4">4x</option>
<option value="6">6x</option>
<option value="8">8x</option>
</select>
<button class="btn" id="saveWebp" title="현재 시트 전체를 WebP 파일로 저장">Sheet</button>
<button class="btn" id="saveSelected" title="선택된 프레임들을 하나의 이미지로 합쳐서 저장">Selected</button>
<button class="btn" id="saveAllZip" title="모든 프레임(36개)을 ZIP 파일로 저장">All</button>
<button class="btn" id="exportFrames" title="선택된 프레임들을 각각 개별 파일로 저장">Frames</button>
</div>
</div>
</div>
<div class="view">
<div class="canvasWrap" id="canvasWrap">
<canvas height="256" id="sheet" width="432"></canvas>
<div class="zoom-controls-overlay">
<button class="btn" id="zoomOutOverlay" title="축소">−</button>
<button class="btn" id="zoomInOverlay" title="확대">＋</button>
<button class="btn" id="zoomFitOverlay" title="화면에 맞춤">Fit</button>
</div>
<!-- NEW: BG picker moved here -->
<div class="bg-color-overlay">
<label for="bgColor">BG</label>
<input id="bgColor" type="color" value="#0b0d12"/>
</div>
</div>
</div>
</div>
</aside>
</div>
<div class="status">
<div class="mono" id="selText">face: -, skin: -, hair: -, clothes: -</div>
<button class="btn" id="copySel" type="button">Copy</button>
</div>
</div>
<script>
(function(){
  const ORDER = ['skin','clothes','face','hair','glass'];
  const PART_LABEL = {face:'얼굴', skin:'피부', hair:'헤어', clothes:'의상', glass:'안경'};
  const PART_ICON = {face:'🙂', skin:'🧴', hair:'✂️', clothes:'👕', glass:'👓'};
  const PARTS = ['face','skin','hair','clothes','glass'];
  const COLORABLE = new Set(['hair','clothes']);
  const COLOR_HEX = ['#111111','#8b8b99','#e58a2b','#f2c94c','#3772ff','#7ed0ff','#8b5e34','#9b59b6','#ff66b3','#eaeaea','#ff3b30','#2ecc71'];
  const BALD_MIN=-144, BALD_MAX=-133;

  const perf = document.getElementById('perf');
  const bgColor = document.getElementById('bgColor');
  const inZip = document.getElementById('inZip');
  const allRand = document.getElementById('allRand');
  const savePng = document.getElementById('savePng');
  const saveWebp = document.getElementById('saveWebp');
  const bodyGrid = document.getElementById('bodyGrid');
  const leftPanel = document.getElementById('leftPanel');
  const toggleLeft = document.getElementById('toggleLeft');
  const tablist = document.getElementById('tablist');
  const grid = document.getElementById('grid');
  const colorBar = document.getElementById('colorBar');
  const canvasWrap = document.getElementById('canvasWrap');
  const cvs = document.getElementById('sheet');
  const ctx = cvs.getContext('2d', {alpha:true}); ctx.imageSmoothingEnabled=false;
  const selText = document.getElementById('selText');
  const copySel = document.getElementById('copySel');
  const zoomInBtn = document.getElementById('zoomInOverlay');
  const zoomOutBtn = document.getElementById('zoomOutOverlay');
  const zoomFitBtn = document.getElementById('zoomFitOverlay');
  const frameIndexEl = document.getElementById('frameIndex');
  const saveFrameBtn = document.getElementById('saveFrame');

  // --- Folder upload (fast path, single render) ---
  const inDir = document.getElementById('inDir');

  function inferPartFromPath(path){
    const low=(path||'').toLowerCase();
    const seg = low.split('/')[0] || '';
    if(['hair','clothes','face','skin','glass'].includes(seg)) return seg;
    const base = low.split('/').pop()||'';
    const m = base.match(/^(hair|clothes|face|skin|glass)[-_]/);
    return m? m[1] : null;
  }
  function inferShapeFromName(name){
    const m = (name||'').match(/(-?\d+)/);
    return m ? parseInt(m[1],10) : null;
  }
  function isPreviewName(name){ return /preview/i.test(name||''); }

  async function addFilesFromList(fileList, targetPart){
    const files = Array.from(fileList||[]);
    if(!files.length) return;

    // Fill assets maps without drawing
    const groups = new Map();
    for(const f of files){
      const rel = f.webkitRelativePath || f.name;
      let part = inferPartFromPath(rel);
      if(!part && targetPart) part = targetPart;
      if(!part) continue;
      if(!groups.has(part)) groups.set(part, []);
      groups.get(part).push(f);
    }
    for(const [part, arr] of groups){
      const map = store.assets[part];
      for(const f of arr){
        const shape = inferShapeFromName(f.name);
        if(shape==null) continue;
        const url = URL.createObjectURL(f);
        let cell = map.get(shape);
        if(!cell) { cell = {url:null, previewUrl:null, name:f.name}; map.set(shape, cell); }
        if(isPreviewName(f.name)) cell.previewUrl = url; else cell.url = url;
        cell.name = f.name;
      }
    }

    // Defaults: prefer -1, else first key
    ['face','skin','hair','clothes','glass'].forEach(p=>{
      if(store.pick[p]!=null) return;
      const m = store.assets[p];
      const keys = [...m.keys()].sort((a,b)=>a-b);
      if(m.has(-1)) store.pick[p] = -1;
      else if(keys.length) store.pick[p] = keys[0];
    });
    if (store.pick.hair!=null) store.color = colorIdxFromShape(store.pick.hair);
    else if (store.pick.clothes!=null) store.color = colorIdxFromShape(store.pick.clothes);

    // Single render pass
    selectPart(store.selPart || 'face');
    await drawSheet();
  }

  if(inDir){
    inDir.addEventListener('change', async (e)=>{
      await addFilesFromList(e.target.files);
      e.target.value='';
    });
  }
  const inFiles = document.getElementById('inFiles');
  if(inFiles){
    inFiles.addEventListener('change', async (e)=>{
      await addFilesFromList(e.target.files, store.selPart || 'face');
      e.target.value='';
    });
  }


  // BG solid
  bgColor.addEventListener('input', e=>{ canvasWrap.style.backgroundImage='none'; canvasWrap.style.backgroundColor=e.target.value; });

  // Left collapse: hide texts when collapsed
  toggleLeft.addEventListener('click', ()=>{
    const collapsed = bodyGrid.classList.toggle('collapsed');
    leftPanel.classList.toggle('collapsed', collapsed);
    toggleLeft.textContent = collapsed ? '▶' : '◀';
  });

  // Tabs with icons and icon-only when collapsed
  PARTS.forEach(p=>{
    const tab=document.createElement('div'); tab.className='tab'; tab.dataset.part=p;
    const name=document.createElement('div'); name.className='name'; name.textContent=PART_LABEL[p];
    const icoPart=document.createElement('div'); icoPart.className='iconPart'; icoPart.textContent=PART_ICON[p];
    const btns=document.createElement('div'); btns.className='rowbtns';
    const icoRandFree=document.createElement('div'); icoRandFree.className='icon'; icoRandFree.title='랜덤+색'; icoRandFree.textContent='🎲';
    const icoRandLock=document.createElement('div'); icoRandLock.className='icon'; icoRandLock.title='랜덤(색 고정)'; icoRandLock.textContent='🔒';
    const icoReset=document.createElement('div'); icoReset.className='icon'; icoReset.title='초기화'; icoReset.textContent='↺';
    icoRandFree.addEventListener('click', (e)=>{ e.stopPropagation(); randomCategory(p, true); });
    icoRandLock.addEventListener('click', (e)=>{ e.stopPropagation(); randomCategory(p, false); });
    icoReset.addEventListener('click', (e)=>{ e.stopPropagation(); resetCategory(p); });
    btns.append(icoRandFree, icoRandLock, icoReset);
    tab.append(name, icoPart, btns);
    tab.addEventListener('click', (e)=>{ if(e.target.closest('.rowbtns')) return; selectPart(p); });
    tablist.appendChild(tab);
  });
  function activateTab(p){ tablist.querySelectorAll('.tab').forEach(el=>el.style.outline = el.dataset.part===p ? '2px solid #6ee7ff' : 'none'); }

  // Color bar
  const colorDots=[];
  COLOR_HEX.forEach((hex,i)=>{ const d=document.createElement('div'); d.className='swatch'; d.style.background=hex; d.dataset.idx=i; d.addEventListener('click',()=>onColorClick(i)); colorBar.appendChild(d); colorDots.push(d); });

  const store = {
    assets:{ face:new Map(), skin:new Map(), hair:new Map(), clothes:new Map(), glass:new Map() },
    selPart:'face',
    color:0,
    pick:{ face:null, skin:null, hair:null, clothes:null, glass:null },
    selectedShapes: new Set(),
    _visibleShapes: [],   // 현재 그리드에 표시 중인 shape들 (필터 반영)
    _anchorShape: null    // Shift 범위 선택 앵커
  };

  function colorIdxFromShape(shape){ return ((-shape - 1) % 12 + 12) % 12; }
  function blockFromShape(shape){ return Math.floor(((-shape - 1) / 12)); }
  function shapeFromBlockColor(block, colorIdx){ return -(block*12 + colorIdx + 1); }
  function isBaldShape(shape){ return shape>=BALD_MIN && shape<=BALD_MAX; }

  function loadImage(url){ return new Promise((res)=>{ const im=new Image(); im.onload=()=>res(im); im.onerror=()=>res(null); im.src=url; }); }
  async function ensureBitmap(obj){ if(!obj || !obj.url) return null; if(obj.img) return obj.img; obj.img = await loadImage(obj.url); return obj.img; }

  // ZIP parse
  inZip.addEventListener('change', async (e)=>{
    const file = e.target.files?.[0]; if(!file) return;
    const buf = await file.arrayBuffer();
    const zip = await JSZip.loadAsync(buf);
    const entries=[];
    zip.forEach((path,en)=>{ if(en.dir) return; const low=path.toLowerCase(); if(!/\.(png|webp|jpe?g)$/.test(low)) return; entries.push(en); });
    entries.sort((a,b)=> a.name.localeCompare(b.name, undefined, {numeric:true}));

    for(const en of entries){
      const path = en.name.replace(/\\/g,'/');
      const folder = (path.split('/')[0]||'').toLowerCase();
      if(!['hair','clothes','face','skin','glass'].includes(folder)) continue;
      const base = path.split('/').pop();
      const isPreview = /preview/i.test(base);
      const m = base.match(/(-?\d+)/); if(!m) continue;
      const shape = parseInt(m[1],10);
      const blob = await en.async('blob');
      const url = URL.createObjectURL(blob);
      const map = store.assets[folder];
      if(!map.has(shape)) map.set(shape, {url:null, previewUrl:null, name:base});
      const cell = map.get(shape);
      if(isPreview) cell.previewUrl = url; else cell.url = url;
      if(!cell.name) cell.name = base;
    }
    e.target.value='';
    // --- Default initialize picks after ZIP parse ---
    (function initDefaultsAfterZip(){
      const partsAll = ['face','skin','hair','clothes','glass'];
      const DEFAULT_SHAPE = -1;
      partsAll.forEach(p=>{
        const map = store.assets[p];
        if (!map || map.size===0) return;
        if (map.has(DEFAULT_SHAPE)) {
          store.pick[p] = DEFAULT_SHAPE;
        } else {
          // fallback: pick the first key (sorted ascending)
          const keys = [...map.keys()].sort((a,b)=>a-b);
          store.pick[p] = keys[0];
        }
      });
      // set initial color bucket based on picked hair (prefer) or clothes
      if (store.pick.hair!=null) {
        store.color = colorIdxFromShape(store.pick.hair);
      } else if (store.pick.clothes!=null) {
        store.color = colorIdxFromShape(store.pick.clothes);
      }
    })();


    // 버튼들 활성화 (안전하게)
    try {
      if(allRand) allRand.disabled=false;
    } catch(e) {
      console.log('Some buttons not found, but continuing...');
    }
    
    selectPart('face'); await drawSheet();
  });

  function selectPart(p){
    store.selPart = p; activateTab(p);
    colorBar.style.display = COLORABLE.has(p)? 'flex':'none';
    buildGrid(); highlightColor();
  }
  window.selectPart = selectPart;

  window.selectPart = selectPart;

  function highlightColor(){ colorDots.forEach((el,i)=> el.classList.toggle('active', i===store.color)); }

  
  // --- Grid selection clear helper (resets state and DOM) ---
  function clearGridSelection(){
    try{
      if (store && store.selectedShapes){
        // Replace with a fresh Set to avoid stale references
        store.selectedShapes.clear();
      }
      if ('_anchorShape' in store) store._anchorShape = null;
    }catch(_){}
    try{
      if (window.clearGridSelection) { window.clearGridSelection(); } else { document.querySelectorAll('.cell.selected').forEach(c=>c.classList.remove('selected')); }
    }catch(_){}
  }
  // expose for external key handlers
  window.clearGridSelection = clearGridSelection;

  function buildGrid(){ const p = store.selPart; const map = store.assets[p]; store._visibleShapes = [];
    
    grid.innerHTML='';
    const frag=document.createDocumentFragment();
    // Add-cell (always first)
    const addCell=document.createElement('div');
    addCell.className='cell add';
    addCell.title='Add images to current part';
    const th=document.createElement('div'); th.className='thumb';
    const plus=document.createElement('div'); plus.className='plus'; plus.textContent='＋';
    th.appendChild(plus);
    const lb=document.createElement('div'); lb.className='label'; lb.textContent='Add';
    addCell.append(th, lb);
    addCell.addEventListener('click', ()=>{ const f=document.getElementById('inFiles'); if(f) f.click(); });
    frag.appendChild(addCell);

    const filter = COLORABLE.has(p) ? store.color : null;
    const shapes = [...map.keys()].sort((a,b)=>a-b);
    for(const shape of shapes){
      if(filter!=null && colorIdxFromShape(shape)!==filter) continue;
      store._visibleShapes.push(shape);
      const item = map.get(shape);
      const d=document.createElement('div'); d.className='cell'; d.dataset.shape=shape;
      const th=document.createElement('div'); th.className='thumb';
      const img=new Image(); img.width=84; img.height=84; img.src=item.previewUrl || item.url; th.appendChild(img);
      const lb=document.createElement('div'); lb.className='label'; lb.textContent=`#${shape}`; lb.title=item.name||`#${shape}`;
      d.append(th,lb);
      if(p==='hair' && isBaldShape(shape)){ const badge=document.createElement('div'); badge.className='badge'; badge.textContent='빈'; d.appendChild(badge); }
      if(store.pick[p]===shape) d.classList.add('active');
      if (store.selectedShapes.size && store.selectedShapes.has(shape)) d.classList.add('selected');
      // Click: choose or toggle selection with modifiers
      d.addEventListener('click', async (e)=>{
        if (e.ctrlKey || e.metaKey) {
          d.classList.toggle('selected');
          if (d.classList.contains('selected')) store.selectedShapes.add(shape);
          else store.selectedShapes.delete(shape);
          store._anchorShape = shape;
          return;
        }
        if (e.shiftKey){
          const vis = store._visibleShapes || [];
          const anchor = store._anchorShape != null ? store._anchorShape : shape;
          const ai = vis.indexOf(anchor);
          const bi = vis.indexOf(shape);
          if (ai !== -1 && bi !== -1){
            const [s,eidx] = ai <= bi ? [ai, bi] : [bi, ai];
            // 덮어쓰기 방식 범위 선택
            store.selectedShapes.clear();
            // DOM 업데이트 전 reset
            if (window.clearGridSelection) { window.clearGridSelection(); } else { document.querySelectorAll('.cell.selected').forEach(c=>c.classList.remove('selected')); }
            for(let k=s;k<=eidx;k++){
              const sh = vis[k];
              store.selectedShapes.add(sh);
            }
            // DOM 표시
            document.querySelectorAll('.cell').forEach(c=>{
              if (c.classList.contains('add')) return;
              const sh = parseInt(c.dataset.shape,10);
              if (store.selectedShapes.has(sh)) c.classList.add('selected');
            });
          }
          return;
        }
         // 일반 클릭: selection 비움 후 pick 지정
        clearGridSelection();
        document.querySelectorAll('.cell.selected').forEach(c=>c.classList.remove('selected'));
        store.pick[p]=shape; 
        store._anchorShape = shape;
        buildGrid(); await drawSheet(); updateSelText();
      });
      frag.appendChild(d);
    }
    grid.appendChild(frag);
    updateSelText();
  }
  window.buildGrid = buildGrid;

  window.buildGrid = buildGrid;


  async function drawSheet(){
    ctx.clearRect(0,0,432,256);
    for(const part of ORDER){
      const shape = store.pick[part];
      const map = store.assets[part];
      if(shape==null || !map || !map.has(shape)) continue;
      const obj = map.get(shape); if(!obj || !obj.url) continue;
      const img = await ensureBitmap(obj); if (img) { ctx.drawImage(img,0,0); }
    }
  }
  window.drawSheet = drawSheet;

  window.drawSheet = drawSheet;



  // --- Delete selected shapes with Delete key (real data removal) ---
  function adjustPickAfterDeletion(part, deletedSet){
    if (store.pick[part]!=null && deletedSet.has(store.pick[part])){
      const keys = [...store.assets[part].keys()].sort((a,b)=>a-b);
      store.pick[part] = keys.length ? keys[0] : null;
    }
  }
  document.addEventListener('keydown', (e)=>{
    // Ctrl+A : 현재 그리드 표시 전부 선택
    if ((e.ctrlKey || e.metaKey) && (e.key === 'a' || e.key === 'A')){
      e.preventDefault();
      const vis = store._visibleShapes || [];
      store.selectedShapes = new Set(vis);
      document.querySelectorAll('.cell').forEach(c=>{
        if (c.classList.contains('add')) return;
        c.classList.add('selected');
      });
      return;
    }
    // Ctrl+Z : 되돌리기
    if ((e.ctrlKey || e.metaKey) && (e.key === 'z' || e.key === 'Z')){
      e.preventDefault();
      const op = (window.__HIST && window.__HIST.stack.length) ? window.__HIST.stack.pop() : null;
      if (op && op.type==='delete'){
        const map = store.assets[op.part];
        op.items.forEach(({shape, cell})=>{
          if (!map.has(shape)) map.set(shape, {url:null, previewUrl:null, name:cell.name||`#${shape}`});
        });
        if (store.pick[op.part]==null){
          const keys=[...map.keys()].sort((a,b)=>a-b);
          store.pick[op.part]=keys.length?keys[0]:null;
        }
        buildGrid(); drawSheet();
      }
      return;
    }
    if (e.key !== 'Delete') return;
    if (store.selectedShapes.size === 0) return;
    const part = store.selPart;
    const count = store.selectedShapes.size;
    if (!confirm(`${count}개의 리소스를 삭제하시겠습니까?`)) return;

    const map = store.assets[part];
    const toDel = new Set(store.selectedShapes);
    // Undo 기록
    if (!window.__HIST) window.__HIST = {stack:[], push(op){this.stack.push(op);}, pop(){return this.stack.pop();}};
    const undoItems = [];
    toDel.forEach(shape=>{
      const cell = map.get(shape);
      if (cell) undoItems.push({shape, cell:{name:cell.name, url:cell.url, previewUrl:cell.previewUrl}});
    });
    window.__HIST.push({type:'delete', part, items:undoItems});
    toDel.forEach(shape=>{
      const cell = map.get(shape);
      if(!cell) return;
      try{
        if (cell.url) URL.revokeObjectURL(cell.url);
        if (cell.previewUrl) URL.revokeObjectURL(cell.previewUrl);
      }catch(_){}
      map.delete(shape);
    });
    adjustPickAfterDeletion(part, toDel);
    store.selectedShapes.clear();
    buildGrid(); drawSheet();
  });

  function onColorClick(ci){
    const p = store.selPart;
    if(COLORABLE.has(p) && store.pick[p]!=null){
      const block = blockFromShape(store.pick[p]);
      const target = shapeFromBlockColor(block, ci);
      if(store.assets[p].has(target)){ store.pick[p]=target; }
    }
    store.color = ci; highlightColor(); buildGrid(); drawSheet();
  }

  // Randoms
  function randomCategory(p, withColor){
    const map = store.assets[p]; const keys=[...map.keys()]; if(!keys.length) return;
    if(COLORABLE.has(p)){
      if(withColor){
        store.pick[p] = keys[Math.floor(Math.random()*keys.length)];
        if(store.selPart===p){ store.color = colorIdxFromShape(store.pick[p]); highlightColor(); }
      }else{
        const bucket = store.color;
        const cand = keys.filter(s=> colorIdxFromShape(s)===bucket );
        store.pick[p] = (cand.length? cand : keys)[Math.floor(Math.random()*(cand.length?cand.length:keys.length))];
      }
    }else{
      store.pick[p] = keys[Math.floor(Math.random()*keys.length)];
    }
    buildGrid(); drawSheet();
  }
  function resetCategory(p){ store.pick[p]=null; buildGrid(); drawSheet(); }

  // All Random (with color)
  allRand.addEventListener('click', ()=>{ ['face','skin','hair','clothes'].forEach(p=> randomCategory(p, true)); });

  // Selection text + Copy
  function updateSelText(){
    const t = `face: ${store.pick.face ?? '-'}, skin: ${store.pick.skin ?? '-'}, hair: ${store.pick.hair ?? '-'}, clothes: ${store.pick.clothes ?? '-'}`;
    selText.textContent = t;
  }
  window.updateSelText = updateSelText;

  window.updateSelText = updateSelText;

  copySel.addEventListener('click', async ()=>{
    try{ await navigator.clipboard.writeText(selText.textContent); copySel.textContent='Copied'; setTimeout(()=>copySel.textContent='Copy',1000); }
    catch{ alert('클립보드 권한이 없습니다. 텍스트를 직접 드래그해 복사하세요.'); }
  });

  // Export: filename as numbers "face,skin,hair,clothes"
  function fileBase(){ return `${store.pick.face ?? '-'},${store.pick.skin ?? '-'},${store.pick.hair ?? '-'},${store.pick.clothes ?? '-'}`; }
  function dl(fmt){ const a=document.createElement('a'); a.download=`${fileBase()}.${fmt}`; a.href=cvs.toDataURL(fmt==='webp'?'image/webp':'image/png',1.0); a.click(); }
  
  // WebP export (Export Sheet)
  const saveWebpBtn = document.getElementById('saveWebp');
  if(saveWebpBtn) {
    saveWebpBtn.addEventListener('click', async ()=>{
      const s = (typeof __getExportScale==='function') ? __getExportScale() : 1;
      const src = document.getElementById('sheet');
      const oc = document.createElement('canvas');
      oc.width = Math.round(src.width * s);
      oc.height = Math.round(src.height * s);
      const octx = oc.getContext('2d', {alpha:true});
      octx.imageSmoothingEnabled = false;
      octx.clearRect(0,0,oc.width,oc.height);
      octx.drawImage(src, 0,0, src.width, src.height, 0,0, oc.width, oc.height);
      const blob = await encodeWebPFromCanvas(oc, {lossless:true, quality:1.0});
      const a = document.createElement('a');
      a.download = (window.fileBase?window.fileBase():'sheet') + `_${s}x.webp`;
      a.href = URL.createObjectURL(blob);
      a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href),1000);
    });
  }

  // Frame picker and Save 48x64
  const COLS=9, ROWS=4, FW=48, FH=64;
  function clampFrame(i){ return Math.max(0, Math.min(COLS*ROWS-1, i|0)); }
  function getFrameXY(i){ const col=i%COLS, row=Math.floor(i/COLS); return {sx:col*FW, sy:row*FH}; }
  if (typeof framePrev !== 'undefined' && framePrev) {
framePrev.addEventListener('click', ()=>{ frameIndexEl.value = clampFrame(+frameIndexEl.value-1); });
}
  if (typeof frameNext !== 'undefined' && frameNext) {
frameNext.addEventListener('click', ()=>{ frameIndexEl.value = clampFrame(+frameIndexEl.value+1); });
}
  if (typeof frameIndexEl !== 'undefined' && frameIndexEl) {
frameIndexEl.addEventListener('change', ()=>{ frameIndexEl.value = clampFrame(+frameIndexEl.value); });
}

  if (saveFrameBtn) {
    saveFrameBtn.addEventListener('click', ()=>{
      const i = clampFrame(+frameIndexEl.value);
      const {sx,sy} = getFrameXY(i);
      const oc = document.createElement('canvas'); oc.width=FW; oc.height=FH;
      const ox = oc.getContext('2d', {alpha:true}); ox.imageSmoothingEnabled=false;
      ox.clearRect(0,0,FW,FH);
      ox.drawImage(cvs, sx, sy, FW, FH, 0, 0, FW, FH);
      const a=document.createElement('a');
      a.download = `${fileBase()}-frame-${i}.png`;
      a.href = oc.toDataURL('image/png',1.0);
      a.click();
    });
  }

  selectPart('face');

  // Preview zoom & pan (left-drag)
  let scale=1;
  function applyZoom(){ cvs.style.width = (432*scale)+'px'; cvs.style.height = (256*scale)+'px'; }
  function fit(){ const wrap=canvasWrap; const s = Math.min((wrap.clientWidth-16)/432, (wrap.clientHeight-16)/256); scale=Math.max(0.25, Math.min(s, 8)); applyZoom(); }
  zoomInBtn.addEventListener('click', ()=>{ scale=Math.min(8, scale*1.25); applyZoom(); });
  zoomOutBtn.addEventListener('click', ()=>{ scale=Math.max(0.25, scale/1.25); applyZoom(); });
  zoomFitBtn.addEventListener('click', fit);
  window.addEventListener('resize', fit); fit();

  let panning=false, sx=0, sy=0, sl=0, st=0;
  canvasWrap.addEventListener('mousedown', (e)=>{ if(e.button!==0) return; panning=true; sx=e.clientX; sy=e.clientY; sl=canvasWrap.scrollLeft; st=canvasWrap.scrollTop; canvasWrap.style.cursor='grabbing'; e.preventDefault(); });
  window.addEventListener('mouseup', ()=>{ if(panning){ panning=false; canvasWrap.style.cursor='default'; }
  suppressNextClick = true; setTimeout(()=>suppressNextClick=false,0);
});
  window.addEventListener('mousemove', (e)=>{ if(!panning) return; canvasWrap.scrollLeft = sl - (e.clientX - sx); canvasWrap.scrollTop = st - (e.clientY - sy); });

  // Splitter
  (function splitter(){
    const split = document.getElementById('split'); let dragging=false, sx=0, startW=0;
    split.addEventListener('mousedown',(e)=>{ dragging=true; sx=e.clientX; startW=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--rightW'))||440; document.body.style.userSelect='none'; });
    window.addEventListener('mousemove', (e)=>{ if(!dragging) return; const dx = sx - e.clientX; let w = startW + dx; w = Math.max(320, Math.min(920, w)); document.documentElement.style.setProperty('--rightW', w+'px'); });
    window.addEventListener('mouseup', ()=>{ dragging=false; document.body.style.userSelect=''; });
  })();

  // perf pulse
  let rafId=null, last=performance.now();
  function tick(t){ const dt=Math.round(t-last); perf.textContent = dt>50?`Busy ${dt}ms`:`Idle`; last=t; rafId=requestAnimationFrame(tick); }
  rafId=requestAnimationFrame(tick);
  try{ window.drawSheet=drawSheet; window.buildGrid=buildGrid; window.updateSelText=updateSelText; window.selectPart=selectPart; }catch(_){/* ignore */}

})();
</script>
<script>
(function(){
  window.__getExportScale = function(){
    const el = document.getElementById('exportScale');
    let s = el ? parseFloat(el.value||'1') : 1;
    if (!Number.isFinite(s) || s<=0) s = 1;
    return Math.min(16, Math.max(1, s));
  };
  const sel = document.getElementById('exportScale');
  if (sel){
    const saved = +localStorage.getItem('exportScale')||1;
    if ([1,2,3,4,6,8,16].includes(saved)) sel.value = String(saved);
    sel.addEventListener('change', ()=>localStorage.setItem('exportScale', sel.value));
  }
})();
</script>
<script>
async function encodeWebPFromCanvas(canvas, {lossless=true, quality=1.0}={}){
  if ('ImageEncoder' in window) {
    const bmp = await createImageBitmap(canvas);
    const enc = new ImageEncoder({type:'image/webp', quality, lossless});
    const reader = enc.encode(bmp).readable.getReader();
    const chunks=[];
    for(;;){ const {value,done}=await reader.read(); if(done) break; chunks.push(value); }
    return new Blob(chunks, {type:'image/webp'});
  }
  return await new Promise(res=> canvas.toBlob(res, 'image/webp', quality));
}
</script>
<script>
// Global fileBase for download handlers in other scripts
window.fileBase = function fileBase(){
  const el = document.getElementById('selText');
  if (el){
    const t = el.textContent || '';
    const face = t.match(/face:\s*([\-\d]+)/i);
    const skin = t.match(/skin:\s*([\-\d]+)/i);
    const hair = t.match(/hair:\s*([\-\d]+)/i);
    const clothes = t.match(/clothes:\s*([\-\d]+)/i);
    if (face && skin && hair && clothes) {
      return `${face[1]},${skin[1]},${hair[1]},${clothes[1]}`;
    }
  }
  return 'sheet';
};
</script>
<script>
document.addEventListener('DOMContentLoaded', ()=>{
  try {
    const cvs = document.getElementById('sheet');
    const wrap = document.getElementById('canvasWrap');
    if (!cvs || !wrap) return;

    // Create overlay canvas for hover/selection
    let overlay = document.getElementById('sheetOverlay');
    if (!overlay){
      overlay = document.createElement('canvas');
      overlay.id = 'sheetOverlay';
      overlay.width = 432; overlay.height = 256;
      overlay.style.position = 'absolute';
      overlay.style.inset = '0';
      overlay.style.pointerEvents = 'none';
      overlay.style.imageRendering = 'pixelated';
      wrap.style.position = 'relative';
      cvs.style.position = 'relative';
      wrap.appendChild(overlay);
    }
    const octx = overlay.getContext('2d', {alpha:true});

    // State
    const state = { anchor: null, selected: new Set(), hover: -1, dragging: false, dragStart: null, dragEnd: null, dirty: true };
    const frameLabel = document.getElementById('frameLabel');
    
    function compressRanges(arr){
      if(arr.length===0) return '-';
      arr.sort((a,b)=>a-b);
      let ranges=[]; let s=arr[0], prev=arr[0];
      for(let i=1;i<arr.length;i++){
        const n=arr[i];
        if(n===prev+1){ prev=n; continue; }
        ranges.push(s===prev?`${s}`:`${s}~${prev}`);
        s=prev=n;
      }
      ranges.push(s===prev?`${s}`:`${s}~${prev}`);
      return ranges.join(',');
    }
    
    function updateFrameLabel(){
      if(!frameLabel) return;
      if(state.selected.size===0){
        frameLabel.textContent = state.hover>=0 ? state.hover : '-';
      } else {
        frameLabel.textContent = compressRanges([...state.selected]);
      }
    }
    
    function frameAtEvent(e){
      const rect = cvs.getBoundingClientRect();
      const sx = (e.clientX - rect.left) * (cvs.width / rect.width);
      const sy = (e.clientY - rect.top) * (cvs.height / rect.height);
      if(sx<0||sy<0||sx>=cvs.width||sy>=cvs.height) return -1;
      const c = Math.floor(sx / 48), r = Math.floor(sy / 64);
      const idx = r*9 + c;
      return (idx>=0 && idx<36) ? idx : -1;
    }
    
    function rectOfIndex(i){
      const c=i%9, r=Math.floor(i/9);
      return {x:c*48, y:r*64, w:48, h:64};
    }
    
    function indexInRect(i, R){
      const a = rectOfIndex(i);
      return !(a.x+a.w <= R.x || a.y+a.h <= R.y || a.x >= R.x+R.w || a.y >= R.y+R.h);
    }
    
    function rangeIndices(a,b){
      const s=Math.min(a,b), e=Math.max(a,b); const out=[];
      for(let i=s;i<=e;i++) out.push(i);
      return out;
    }
    
    function drawOverlay(){
      if(!state.dirty) return;
      state.dirty=false;
      const r = cvs.getBoundingClientRect();
      overlay.style.width = Math.round(r.width) + 'px';
      overlay.style.height = Math.round(r.height) + 'px';
      octx.clearRect(0,0,overlay.width, overlay.height);
      
      // hover
      if (state.hover>=0){
        const c=state.hover%9, r=Math.floor(state.hover/9);
        octx.save(); octx.strokeStyle='#ffffffb3'; octx.lineWidth=2; octx.strokeRect(c*48+1, r*64+1, 46, 62); octx.restore();
      }
      
      // drag marquee
      if (state.dragging && state.dragStart!=null && state.dragEnd!=null){
        const a = rectOfIndex(state.dragStart);
        const b = rectOfIndex(state.dragEnd);
        const R = { x: Math.min(a.x,b.x), y: Math.min(a.y,b.y),
                    w: Math.abs((a.x)-(b.x)) + 48, h: Math.abs((a.y)-(b.y)) + 64 };
        octx.save();
        octx.strokeStyle='#70b2ff'; octx.setLineDash([4,3]); octx.strokeRect(R.x+0.5, R.y+0.5, R.w-1, R.h-1);
        octx.restore();
      }
      
      // selected
      state.selected.forEach(i=>{
        const c=i%9, r=Math.floor(i/9);
        octx.save(); octx.strokeStyle='#4ea1ff'; octx.lineWidth=2; octx.strokeRect(c*48+1, r*64+1, 46, 62); octx.restore();
      });
    }
    
    // RAF loop
    function loop(){ drawOverlay(); requestAnimationFrame(loop); updateFrameLabel(); }
    requestAnimationFrame(loop);
    updateFrameLabel();

    // Buttons
    const tools = document.querySelector('.tools');
    let btnSaveSel = document.getElementById('saveSelected');
    let btnSaveAll = document.getElementById('saveAllZip');
    let btnExportFrames = document.getElementById('exportFrames');
    
    // Events
    cvs.addEventListener('mousemove', (e)=>{ const idx = frameAtEvent(e); state.hover = idx; if(state.dragging){ state.dragEnd = (idx<0? state.dragEnd : idx); } state.dirty=true; updateFrameLabel(); });
    cvs.addEventListener('mouseleave', ()=>{ state.hover=-1; state.dirty=true; updateFrameLabel(); });
    cvs.addEventListener('mousedown', (e)=>{
      if (e.button!==0) return;
      const idx = frameAtEvent(e); if (idx<0) return;
      state.dragging=true; state.dragStart=idx; state.dragEnd=idx; state.dirty=true; updateFrameLabel();
    });
    
    // 다른 영역 클릭시 선택 해제
    document.addEventListener('click', (e)=>{
      if (!cvs.contains(e.target) && !e.target.closest('.canvasWrap')) {
        if (state.selected.size > 0) {
          state.selected.clear();
          state.anchor = null;
          state.dirty = true;
          updateFrameLabel();
        }
      }
    });
    
    // 시트 미리보기 영역에서 시트가 아닌 곳 클릭시 선택 해제
    canvasWrap.addEventListener('click', (e)=>{
      if (!cvs.contains(e.target)) {
        if (state.selected.size > 0) {
          state.selected.clear();
          state.anchor = null;
          state.dirty = true;
          updateFrameLabel();
        }
      }
    });
    
    // ESC 키로 선택 해제
    document.addEventListener('keydown', (e)=>{
      if (e.key === 'Escape') {
        if (state.selected.size > 0) {
          state.selected.clear();
          state.anchor = null;
          state.dirty = true;
          updateFrameLabel();
        }
      }
    });
    
    // 우클릭 복사 기능 추가
    cvs.addEventListener('contextmenu', async (e)=>{
      if (state.selected.size === 0) return;
      e.preventDefault();
      
      const list = [...state.selected].sort((a,b)=>a-b);
      const oc = document.createElement('canvas'); 
      oc.width = 48 * list.length; 
      oc.height = 64;
      const g = oc.getContext('2d'); 
      g.imageSmoothingEnabled = false;
      
      list.forEach((i,k)=>{
        const sx=(i%9)*48, sy=Math.floor(i/9)*64;
        g.drawImage(cvs, sx, sy, 48,64, 48*k, 0, 48,64);
      });
      
      try{
        let blob;
        if (oc.convertToBlob) {
          blob = await oc.convertToBlob({type:'image/png'});
        } else {
          blob = await new Promise(res=>oc.toBlob(res, 'image/png'));
        }
        await navigator.clipboard.write([ new ClipboardItem({ 'image/png': blob }) ]);
        
        const perf = document.getElementById('perf');
        if (perf) { 
          const old=perf.textContent; 
          perf.textContent=`✅ Copied ${list.length} frames`; 
          perf.style.color = '#2ecc71';
          perf.style.fontWeight = 'bold';
          setTimeout(()=>{
            perf.textContent=old; 
            perf.style.color = '';
            perf.style.fontWeight = '';
          }, 1500); 
        }
        
        state.selected.forEach(i=>{
          const c=i%9, r=Math.floor(i/9);
          octx.save(); 
          octx.strokeStyle='#2ecc71'; 
          octx.lineWidth=3; 
          octx.strokeRect(c*48+1, r*64+1, 46, 62);
          octx.restore();
        });
        state.dirty = true;
        
        setTimeout(()=>{
          state.dirty = true;
        }, 1000);
        
      }catch(err){
        try{
          const url = oc.toDataURL('image/png');
          const w = window.open('', '_blank');
          if (w && w.document) {
            w.document.title = (window.fileBase ? window.fileBase() : 'copied') + ' (copied fallback)';
            const img = new Image(); 
            img.src = url; 
            img.style.imageRendering='pixelated';
            img.style.width = (oc.width*3)+'px'; 
            img.style.height = (oc.height*3)+'px';
            w.document.body.style.margin='0'; 
            w.document.body.style.background='#111';
            w.document.body.appendChild(img);
          } else {
            alert('클립보드 복사 실패. 새 탭으로 이미지를 열었습니다.');
            window.open(url, '_blank');
          }
        }catch(_){ 
          alert('복사 실패'); 
        }
      }
    });
    
    window.addEventListener('mouseup', (e)=>{
      if (!state.dragging) return;
      state.dragging=false;
      const a = state.dragStart, b = state.dragEnd;
      if (a!=null && b!=null){
        const A = rectOfIndex(a), B = rectOfIndex(b);
        const R = { x: Math.min(A.x,B.x), y: Math.min(A.y,B.y),
                    w: Math.abs(A.x-B.x)+48, h: Math.abs(A.y-B.y)+64 };
        let set = new Set();
        for(let i=0;i<36;i++) if(indexInRect(i,R)) set.add(i);
        if (e.ctrlKey || e.metaKey){
          set.forEach(i=>{ if(state.selected.has(i)) state.selected.delete(i); else state.selected.add(i); });
        } else {
          state.selected = set;
        }
        state.anchor = b;
      }
      state.dragStart=null; state.dragEnd=null; state.dirty=true; updateFrameLabel();
    }, {capture:true});

    cvs.addEventListener('click', (e)=>{
      if (suppressNextClick) { return; }
      if (state.dragging) return;
      const idx = frameAtEvent(e); if (idx<0) return;
      if (e.shiftKey){
        if (state.anchor==null) state.anchor=idx;
        const range = rangeIndices(state.anchor, idx);
        if (e.ctrlKey || e.metaKey){
          range.forEach(i=>{ if(state.selected.has(i)) state.selected.delete(i); else state.selected.add(i); });
        } else {
          state.selected = new Set(range);
        }
      } else if (e.ctrlKey || e.metaKey){
        if (state.selected.has(idx)) state.selected.delete(idx); else state.selected.add(idx);
        state.anchor = idx;
      } else {
        state.selected = new Set([idx]);
        state.anchor = idx;
      }
      state.dirty=true; updateFrameLabel();
    });

    // Save Selected
    if (btnSaveSel){
      btnSaveSel.addEventListener('click', async ()=>{
        if (state.selected.size===0) return;
        const list=[...state.selected].sort((a,b)=>a-b);
        const s = (typeof __getExportScale==='function') ? __getExportScale() : 1;
        const oc=document.createElement('canvas'); oc.width=48*s*list.length; oc.height=64*s;
        const octx2=oc.getContext('2d'); octx2.imageSmoothingEnabled=false;
        list.forEach((i,k)=>{ const sx=(i%9)*48, sy=Math.floor(i/9)*64; octx2.drawImage(cvs, sx, sy, 48,64, 48*s*k, 0, 48*s, 64*s); });
        const blob = await encodeWebPFromCanvas(oc, {lossless:true, quality:1.0});
        const a=document.createElement('a');
        a.download = `${window.fileBase()}-frame-${compressRanges(list)}_${s}x.webp`; a.href=URL.createObjectURL(blob); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),1000);
      });
    }
    
    // Save All (ZIP)
    if (btnSaveAll){
      btnSaveAll.addEventListener('click', async ()=>{
        if (!window.JSZip){ alert('JSZip not loaded'); return; }
        const zip = new JSZip();
        const currentNumbers = window.fileBase ? window.fileBase() : '0,0,0,0';
        const [faceNum, skinNum, hairNum, clothesNum] = currentNumbers.split(',');
        const s = (typeof __getExportScale==='function') ? __getExportScale() : 1;
        const zipFileName = `frame_all_${faceNum}${skinNum}${hairNum}${clothesNum}_0~35_${s}x.zip`;
        for(let i=0;i<36;i++){
          const sx=(i%9)*48, sy=Math.floor(i/9)*64;
          const oc=document.createElement('canvas'); oc.width=48*s; oc.height=64*s;
          oc.getContext('2d').drawImage(cvs, sx, sy,48,64,0,0,48*s,64*s);
          const blob=await encodeWebPFromCanvas(oc,{lossless:true,quality:1.0});
          const b64 = await new Promise(r=>{ const fr=new FileReader(); fr.onload=()=>r(fr.result.split(',')[1]); fr.readAsDataURL(blob); });
          zip.file(`frame_${faceNum}${skinNum}${hairNum}${clothesNum}_${i}.webp`, b64, {base64:true});
        }
        const cont = await zip.generateAsync({type:'blob'});
        const a=document.createElement('a'); a.download=zipFileName; a.href=URL.createObjectURL(cont); a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),1000);
      });
    }

    // Export Frames (개별 파일로 저장)
    if (btnExportFrames){
      btnExportFrames.addEventListener('click', async ()=>{
        if (state.selected.size===0) return;
        const list=[...state.selected].sort((a,b)=>a-b);
        const baseName = window.fileBase();
        
        for(let i=0; i<list.length; i++){
          const s = (typeof __getExportScale==='function') ? __getExportScale() : 1;
          const frameIdx = list[i];
          const oc=document.createElement('canvas'); oc.width=48*s; oc.height=64*s;
          const octx2=oc.getContext('2d'); octx2.imageSmoothingEnabled=false;
          const sx=(frameIdx%9)*48, sy=Math.floor(frameIdx/9)*64;
          octx2.drawImage(cvs, sx, sy, 48,64, 0, 0, 48*s,64*s);
          const blob = await encodeWebPFromCanvas(oc, {lossless:true, quality:1.0});
          const a=document.createElement('a'); 
          a.download = `${baseName}-frame-${frameIdx}_${s}x.webp`; 
          a.href=URL.createObjectURL(blob); 
          a.click(); 
          setTimeout(()=>URL.revokeObjectURL(a.href),1000);
          
          if(i < list.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 100));
          }
        }
      });
    }

  } catch(err) {
    console.error('select-pack init error', err);
  }
});
</script>
<script>
document.addEventListener("DOMContentLoaded", function() {
  const canvasWrap = document.getElementById("canvasWrap");
  if (canvasWrap) {
    canvasWrap.addEventListener("wheel", function(e) {
      e.preventDefault();
      if (e.deltaY < 0) {
        var zoomInBtn = document.getElementById("zoomIn") || document.getElementById("zoomInOverlay");
        if (zoomInBtn) zoomInBtn.click();
      } else {
        var zoomOutBtn = document.getElementById("zoomOut") || document.getElementById("zoomOutOverlay");
        if (zoomOutBtn) zoomOutBtn.click();
      }
    }, { passive: false });
  }
});
</script>
<script>
(function(){
  const grid = document.getElementById('grid');
  if (!grid) return;

  // 기준값(현재 CSS와 일치)
  const BASE = { cellW: 90, cellH: 106, img: 84 };
  let gridScale = 1; // 0.5~3 권장

  // 동적 스타일
  let styleEl = document.getElementById('gridZoomStyle');
  if (!styleEl){
    styleEl = document.createElement('style');
    styleEl.id = 'gridZoomStyle';
    document.head.appendChild(styleEl);
  }

  function applyGridZoom(){
    const cw = Math.max(40, Math.round(BASE.cellW * gridScale));
    const ch = Math.max(46, Math.round(BASE.cellH * gridScale));
    const im = Math.max(32, Math.round(BASE.img * gridScale));

    // 열 폭과 "행 높이"를 동시에 조정
    grid.style.gridTemplateColumns = `repeat(auto-fill, minmax(${cw}px,1fr))`;
    grid.style.gridAutoRows = `${ch}px`;

    // 셀 내부 넘침 방지 및 이미지 크기 조정
    styleEl.textContent = `
      .grid .cell{height:auto; overflow:hidden;}
      .grid .cell .thumb img{width:${im}px;height:${im}px;image-rendering:pixelated}
    `;
  }
  applyGridZoom();

  function zoom(dir){ // +1 확대, -1 축소
    const factor = (dir > 0) ? 1.15 : 1/1.15;
    gridScale = Math.min(3, Math.max(0.5, gridScale * factor));
    applyGridZoom();
  }

  // 중앙 영역 휠 줌
  grid.addEventListener('wheel', (e)=>{
    if (!(e.ctrlKey || e.metaKey)) return; // Ctrl/⌘ + wheel only
    e.preventDefault();
    zoom(e.deltaY < 0 ? +1 : -1);
  }, { passive:false });
// 단축키: Ctrl/⌘ + 0 = reset only
  document.addEventListener('keydown', (e)=>{
    if (/(INPUT|TEXTAREA|SELECT)/.test(e.target.tagName)) return;
    if ((e.ctrlKey||e.metaKey) && (e.key==='0')) { e.preventDefault(); gridScale=1; applyGridZoom(); }
  });
})();
</script>
<script>
(function(){
  const selText = document.getElementById('selText');
  if(!selText) return;
  selText.addEventListener('keypress', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); } });
  selText.addEventListener('paste', (e)=>{
    e.preventDefault();
    const txt = (e.clipboardData || window.clipboardData).getData('text');
    const clean = (txt||'').replace(/\r|\n/g,' ').replace(/\s+/g,' ').trim();
    document.execCommand('insertText', false, clean);
  });
})();
</script>


<!-- PATCH: robust ZIP loader with fallbacks + local file picker -->
<script>
(function(){
  // Config
  const DEFAULTS = ["assets/current.zip", "assets/avatar-parts-webp.zip"];
  const PARTS = ["face","skin","hair","clothes","glass","hat","mask","beard","back","front","necklace","shirt","eyes","eyebrow","mouth","ear","body"];

  function parseQuery(){
    const p = new URLSearchParams(location.search);
    const z = p.get("zip");
    return { zip: z };
  }

  function hud(msg, ok=true, keepMs=2500){
    let el = document.getElementById("__zip_hud__");
    if (!el){
      el = document.createElement('div');
      el.id = "__zip_hud__";
      el.style.cssText = 'position:fixed;bottom:8px;right:8px;padding:8px 12px;background:#111;color:#fff;font:12px monospace;border-radius:8px;opacity:.95;z-index:99999;box-shadow:0 4px 10px rgba(0,0,0,.25)';
      document.body.appendChild(el);
    }
    el.style.background = ok ? '#111' : '#822';
    el.textContent = msg;
    if (keepMs>0) setTimeout(()=>{ if (el) el.remove(); }, keepMs);
    return el;
  }

  async function fetchZip(url){
    console.log("[ZIP] fetching:", url);
    const res = await fetch(url, { cache: 'no-cache' });
    if (!res.ok) {
      const err = new Error(`HTTP ${res.status} for ${url}`);
      err.status = res.status;
      err.url = url;
      throw err;
    }
    return res.arrayBuffer();
  }

  async function tryLoadZip(urls){
    let lastErr = null;
    for (const u of urls){
      try{
        hud(`Loading ZIP: ${u} ...`, true, 0);
        const buf = await fetchZip(u);
        hud(`ZIP loaded: ${u}`, true, 1500);
        return {buf, from:u};
      }catch(e){
        console.warn("[ZIP] failed:", e);
        lastErr = e;
      }
    }
    throw lastErr || new Error("No ZIP candidate worked");
  }

  async function zipToAssets(buf){
    const zip = await JSZip.loadAsync(buf);
    // Collect .webp entries
    const entries = [];
    zip.forEach((rel, file) => {
      if (!file.dir && /\.webp$/i.test(rel)) entries.push({ name: rel, file });
    });
    // Group
    const grouped = {};
    for (const part of PARTS) grouped[part] = new Map();
    for (const e of entries){
      const path = e.name.replace(/^\.?\/*/, "");
      const segs = path.split("/");
      if (segs.length < 2) continue;
      const part = segs[0];
      if (!PARTS.includes(part)) continue;
      const filename = segs[segs.length-1];
      const mPrev = filename.match(/^(.+)_preview\.webp$/i);
      const mMain = filename.match(/^(.+)\.webp$/i);
      if (!mPrev && !mMain) continue;
      const keyStr = (mPrev ? mPrev[1] : mMain[1]);
      const n = parseInt(keyStr, 10);
      const key = Number.isFinite(n) ? n : keyStr;
      const obj = grouped[part].get(key) || { name: `#${keyStr}` };
      if (mPrev) obj._prev = e.file;
      if (mMain) obj._main = e.file;
      grouped[part].set(key, obj);
    }
    // Blob URLs
    for (const part of Object.keys(grouped)){
      for (const [key, obj] of grouped[part].entries()){
        let mainUrl=null, prevUrl=null;
        if (obj._main){ const b = await obj._main.async("blob"); mainUrl = URL.createObjectURL(b); }
        if (obj._prev){ const b2= await obj._prev.async("blob"); prevUrl = URL.createObjectURL(b2); }
        if (!mainUrl && prevUrl) mainUrl = prevUrl;
        if (!prevUrl && mainUrl) prevUrl = mainUrl;
        grouped[part].set(key, { url: mainUrl, previewUrl: prevUrl, name: obj.name });
      }
    }
    return grouped;
  }

  function applyAssets(grouped){
    window.store = window.store || {};
    store.assets = store.assets || {};
    for (const part of Object.keys(grouped)){
      store.assets[part] = grouped[part];
    }
    store.pick = store.pick || { face:-1, skin:-1, hair:-1, clothes:-1 };
  }

  function showPicker(onPick){
    // Floating panel
    const wrap = document.createElement('div');
    wrap.style.cssText = 'position:fixed;bottom:12px;left:12px;background:#1e1e1e;color:#fff;padding:10px 12px;border-radius:10px;font:12px monospace;z-index:99999;box-shadow:0 6px 18px rgba(0,0,0,.35)';
    wrap.innerHTML = `
      <div style="margin-bottom:6px">ZIP를 선택해서 로드할 수 있습니다.</div>
      <input type="file" accept=".zip" id="__zip_file__">
      <button id="__zip_close__" style="margin-left:8px;">닫기</button>
    `;
    document.body.appendChild(wrap);
    const inp = wrap.querySelector('#__zip_file__');
    const closeBtn = wrap.querySelector('#__zip_close__');
    inp.addEventListener('change', async (e)=>{
      const f = inp.files && inp.files[0];
      if (!f) return;
      hud(`Loading local ZIP: ${f.name} ...`, true, 0);
      try{
        const buf = await f.arrayBuffer();
        await onPick(buf);
        hud(`Loaded local ZIP: ${f.name}`, true, 2000);
        wrap.remove();
      }catch(err){
        hud(`로컬 ZIP 로드 실패: ${err.message}`, false, 4000);
      }
    });
    closeBtn.addEventListener('click', ()=>wrap.remove());
  }

  async function boot(){
    const {zip} = parseQuery();
    const candidates = zip ? [zip] : DEFAULTS.slice();
    try{
      const {buf, from} = await tryLoadZip(candidates);
      const grouped = await zipToAssets(buf);
      applyAssets(grouped);
      let total=0; for (const p of Object.keys(store.assets)) total+=store.assets[p].size;
      hud(`ZIP OK: ${from} (${total} items)`);
      try { if (typeof window.drawSheet==='function') await window.drawSheet(); } catch(e){ console.warn(e); }
    }catch(err){
      console.warn("All ZIP fetch failed.", err);
      hud(`ZIP 404/에러: ${err.url||''} → 로컬 ZIP 선택 가능`, false, 4000);
      showPicker(async (buf)=>{
        const grouped = await zipToAssets(buf);
        applyAssets(grouped);
        let total=0; for (const p of Object.keys(store.assets)) total+=store.assets[p].size;
        try { if (typeof window.drawSheet==='function') await window.drawSheet(); } catch(e){}
      });
    }
  }

  window.addEventListener('load', boot);
})();
</script>


</body></html>